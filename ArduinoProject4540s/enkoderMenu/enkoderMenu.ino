///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  ███████╗███╗   ██╗██╗  ██╗ ██████╗ ██████╗ ███████╗██████╗         ███████╗        ███╗   ███╗███████╗███╗   ██╗██╗   ██╗
//  ██╔════╝████╗  ██║██║ ██╔╝██╔═══██╗██╔══██╗██╔════╝██╔══██╗        ██╔════╝        ████╗ ████║██╔════╝████╗  ██║██║   ██║
//  █████╗  ██╔██╗ ██║█████╔╝ ██║   ██║██║  ██║█████╗  ██████╔╝        ███████╗        ██╔████╔██║█████╗  ██╔██╗ ██║██║   ██║
//  ██╔══╝  ██║╚██╗██║██╔═██╗ ██║   ██║██║  ██║██╔══╝  ██╔══██╗        ╚════██║        ██║╚██╔╝██║██╔══╝  ██║╚██╗██║██║   ██║
//  ███████╗██║ ╚████║██║  ██╗╚██████╔╝██████╔╝███████╗██║  ██║        ███████║        ██║ ╚═╝ ██║███████╗██║ ╚████║╚██████╔╝
//  ╚══════╝╚═╝  ╚═══╝╚═╝  ╚═╝ ╚═════╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝        ╚══════╝        ╚═╝     ╚═╝╚══════╝╚═╝  ╚═══╝ ╚═════╝ 
//                                                                                                                           
//  ██╗   ██╗██╗██████╗  ██████╗ ██████╗             ████████╗██╗██████╗  █████╗              ██████╗             ██╗        
//  ██║   ██║██║██╔══██╗██╔═══██╗██╔══██╗            ╚══██╔══╝██║██╔══██╗██╔══██╗            ██╔═████╗    ██╗    ███║        
//  ██║   ██║██║██████╔╝██║   ██║██████╔╝               ██║   ██║██████╔╝███████║            ██║██╔██║    ╚═╝    ╚██║        
//  ╚██╗ ██╔╝██║██╔══██╗██║   ██║██╔══██╗               ██║   ██║██╔═══╝ ██╔══██║            ████╔╝██║    ██╗     ██║        
//   ╚████╔╝ ██║██████╔╝╚██████╔╝██║  ██║               ██║   ██║██║     ██║  ██║            ╚██████╔╝    ╚═╝     ██║        
//    ╚═══╝  ╚═╝╚═════╝  ╚═════╝ ╚═╝  ╚═╝               ╚═╝   ╚═╝╚═╝     ╚═╝  ╚═╝             ╚═════╝             ╚═╝        
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  НАСТРОЙКА:
#define ENKODER_MENU_TYPE 1  // 0 без меню, 1 с меню
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//   ██╗            ███████╗            ███╗   ███╗    ███████╗    ███╗   ██╗    ██╗   ██╗
//  ███║            ██╔════╝            ████╗ ████║    ██╔════╝    ████╗  ██║    ██║   ██║
//  ╚██║            ███████╗            ██╔████╔██║    █████╗      ██╔██╗ ██║    ██║   ██║
//   ██║            ╚════██║            ██║╚██╔╝██║    ██╔══╝      ██║╚██╗██║    ██║   ██║
//   ██║            ███████║            ██║ ╚═╝ ██║    ███████╗    ██║ ╚████║    ╚██████╔╝
//   ╚═╝            ╚══════╝            ╚═╝     ╚═╝    ╚══════╝    ╚═╝  ╚═══╝     ╚═════╝ 
                                                                                                                   
#if ENKODER_MENU_TYPE == 1  ////////////////////////////////>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Объявляем переменные

int pinA      = 2; //Пин прерывания сигнальной линии
int pinButton = 3; //Пин прерывания нажатия кнопки
int pinB      = 4; //Любой другой пин

long timeButtonPressed = 1500; // Долгое удержание кнопки после 1,5 секунд

volatile int state = 0;       // Статус одного шага - от 0 до 4 в одну сторону, от 0 до -4 - в другую

// Переменные хранящие состояние действия до его выполнения
volatile bool flagCW            = false;     // Было ли вращение по часовой стрелке
volatile bool flagCCW           = false;     // Было ли вращение против часовой стрелки
volatile bool flagButton        = false;     // Было ли нажатие кнопки
volatile bool flagButtonLong    = false;     // Было ли долгое удержание кнопки

volatile long timeButtonDown    = 0;         // Переменная хранящая время нажатия кнопки
volatile bool isButtonDown      = false;     // Переменная хранящая время нажатия кнопки
volatile bool longPressReleased = false;     // Переменная для фиксации срабатывания долгого нажатия

struct menu                             // Структура описывающая меню
{
  int id;                               // Идентификационный уникальный индекс ID
  int parentid;                         // ID родителя
  bool isParam;                         // Является ли пункт изменяемым параметром
  String _name;                         // Название
  int value;                            // Актуальное значение
  int _min;                             // Минимально возможное значение параметра
  int _max;                             // Максимально возможное значение параметра
};

int menuArraySize = 22;                 // Задаем размер массива
menu menus[] = {                        // Задаем пункты меню
  {0, -1, false, "Main", 0, 0, 0},
  {1, 0, false, "      File", 0, 0, 0},
  {2, 1, false, "            New", 0, 0, 0},
  {3, 1, false, "            Open", 0, 0, 0},
  {4, 1, false, "            Save", 0, 0, 0},
  {5, 1, false, "            Close", 0, 0, 0},
  {6, 1, false, "            Options", 0, 0, 0},
  {7, 6, false, "                  General", 0, 0, 0},
  {8, 6, false, "                  Presets", 0, 0, 0},
  {9, 6, false, "                  Network", 0, 0, 0},
  {10, 6, false, "                  Reset", 0, 0, 0},
  {11, 0, false, "      Edit", 0, 0, 0},
  {12, 11, false, "            Cut", 0, 0, 0},
  {13, 11, false, "            Copy", 0, 0, 0},
  {14, 11, false, "            Paste", 0, 0, 0},
  {15, 0, false, "      Effects", 0, 0, 0},
  {16, 15, true, "            Brightness ", 0, -50, 50},
  {17, 15, true, "            Contrast", 10, -50, 50},
  {18, 15, true, "            Exposure", 10, -100, 100},
  {19, 15, true, "            Highlights", 5, 0, 50},
  {20, 15, true, "            Shadows", 0, 0, 10},
  {21, 15, true, "            Clarity", 1, -10, 10}
};
int actualIndex = 0;

void setup()
{
  actualIndex = getMenuIndexByID(0);    // Main - актуальный элемент меню

  pinMode(pinA, INPUT);                 // Пины в режим приема INPUT
  pinMode(pinB, INPUT);                 // Пины в режим приема INPUT
  pinMode(pinButton, INPUT);            // Пины в режим приема INPUT

  attachInterrupt(0, A, CHANGE);        // Настраиваем обработчик прерываний по изменению сигнала
  attachInterrupt(1, Button, CHANGE);   // Настраиваем обработчик прерываний по изменению сигнала нажатия кнопки

  Serial.begin(9600);                   // Включаем Serial

  setActualMenu(0, 0);                  // Выводим в Serial актуальный элемент меню
}

void loop()
{
  int vmenu = 0;                        // Переменная хранящая действие по вертикали 1 - вход в меню, -1 - выход из меню
  int hmenu = 0;                        // Переменная хранящая действие по горизонтали 1 - вправо, -1 - влево

  if (millis() - timeButtonDown > timeButtonPressed && isButtonDown) { // Время длительного удержания наступило
    flagButtonLong = true;
  }

  if (flagCW) {               // Шаг вращения по часовой стрелке
    hmenu = 1;
    //Serial.println("right");
    flagCW = false;           // Действие обработано - сбрасываем флаг
  }
  if (flagCCW) {              // Шаг вращения против часовой стрелки
    hmenu = -1;
    //Serial.println("left");
    flagCCW = false;          // Действие обработано - сбрасываем флаг
  }
  if (flagButton) {           // Кнопка нажата
    vmenu = 1;                // По нажатию кнопки - переходим на уровень вниз
    //Serial.println("button");
    flagButton = false;       // Действие обработано - сбрасываем флаг
  }
  if (flagButtonLong && isButtonDown) {   // Кнопка удерживается
    if (!digitalRead(pinButton) && millis() - timeButtonDown > timeButtonPressed) { // Защита от ложного срабатывания
      // ...
      vmenu = -1;             // По удержанию кнопки - возвращаемся на уровень вверх
      //Serial.println("long_press");
    }
    
    //=========================================== Настраиваем реакцию на долгое удержание кнопки ===============================================
    // Чтобы событие long_press во время удержания срботало только один раз, необходимо раскомментировать блок и закомментировать следующий
    //isButtonDown = false;                 // Программно "отжимаем" кнопку

    // Эти две строки отвечают за то, чтобы при долгом удержании кнопки, событие long_press повторялось каждые 1,5 секунды
    // Для того, чтобы изменить это поведение нужно закомментировать две эти строки и раскомментировать строку из предыдущего блока
    timeButtonDown = millis();            // Сбрасываем таймер
    longPressReleased = true;             // Флаг срабатывания долгого удержания, чтобы отсечь генерацию обычного нажатия при отпускании кнопки
    //==========================================================================================================================================

    flagButtonLong = false;               // Действие обработано - сбрасываем флаг
  }
  if (vmenu != 0 || hmenu != 0) setActualMenu(vmenu, hmenu); // Если было действие - реагируем на него

}

bool isParamEditMode  = false;                            // Флаг режима редактирования параметра
int tmpValue          = 0;                                // Временная переменная для хранения изменяемого параметра
void setActualMenu(int v, int h) {
  if (v != 0) {                                           // Двигаемся по вертикали
    if (v == -1) {                                        // Команда ВВЕРХ (отмена)
      if (isParamEditMode) {                              // Если параметр в режиме редактирования, то отменяем изменения
        isParamEditMode = false;
      }
      else {                                              // Если пункт меню не в режиме редактирования, перемещаемся к родителю
        if (menus[actualIndex].parentid > 0) {            // Если есть куда перемещаться вверх (ParentID>0)
          actualIndex = getMenuIndexByID(menus[actualIndex].parentid);
        }
      }
    }
    else {                                                // Если команда ВНИЗ - входа/редактирования
      if (menus[actualIndex].isParam && !isParamEditMode) { // Если не в режиме редактирования, то ...
        isParamEditMode = true;                           // Переходим в режим редактирования параметра
        tmpValue = menus[actualIndex].value;              // Временной переменной присваиваем актуальное значение параметра
      }
      else if (menus[actualIndex].isParam && isParamEditMode) { // Если в режиме редактирования
        menus[actualIndex].value = tmpValue;              // Сохраняем заданное значение
        isParamEditMode = false;                          // И выходим из режима редактирования

      }
      else {
        bool nochild = true;                              // Флаг, есть ли дочерние элементы
        for (int i = 0; i < menuArraySize; i++) {
          if (menus[i].parentid == menus[actualIndex].id) {
            actualIndex = i;                              // Если есть, делаем первый попавшийся актуальным элементом
            nochild = false;                              // Потомки есть
            break;                                        // Выходим из for
          }
        }
        if (nochild) {                                    // Если же потомков нет, воспринимаем как команду
          Serial.println("Executing command...");         // И здесь обрабатываем по своему усмотрению
        }
      }
    }
  }

  if (h != 0) {                                           // Если горизонтальная навигация
    if (isParamEditMode) {                                // В режиме редактирования параметра
      tmpValue += h;                                      // Изменяем его значение и ...
      // ... контроллируем, чтобы оно осталось в заданном диапазоне
      if (tmpValue > menus[actualIndex]._max) tmpValue = menus[actualIndex]._max;
      if (tmpValue < menus[actualIndex]._min) tmpValue = menus[actualIndex]._min;
    }
    else {                                                // Если режим редактирования не активен, навигация среди потомков одного родителя
      actualIndex = getNearMenuIndexByID(menus[actualIndex].parentid, menus[actualIndex].id, h);
    }
  }

  // Отображаем информацию в Serial
  if (isParamEditMode) {
    Serial.println(" > " + (String)menus[actualIndex]._name + ": " +
                   (String)tmpValue +
                   "  min:" + (String)menus[actualIndex]._min +
                   ", max:" + (String)menus[actualIndex]._max);
  }
  else {
    if (menus[actualIndex].isParam) {
      Serial.println((String)menus[actualIndex]._name + ": " + (String)menus[actualIndex].value);
    }
    else {
      Serial.println((String)menus[actualIndex]._name);
    }
  }
}


int getMenuIndexByID(int id) {        // Функция получения индекса пункта меню по его ID
  for (int i = 0; i < menuArraySize; i++) {
    if (menus[i].id == id)  return i;
  }
  return -1;
}

int getNearMenuIndexByID(int parentid, int id, int side) { // Функция получения индекса пункта меню следующего или предыдущего от актуального
  int prevID    = -1;   // Переменная для хранения индекса предыдущего элемента
  int nextID    = -1;   // Переменная для хранения индекса следующего элемента
  int actualID  = -1;   // Переменная для хранения индекса актуального элемента

  int firstID   = -1;   // Переменная для хранения индекса первого элемента
  int lastID    = -1;   // Переменная для хранения индекса последнего элемента

  for (int i = 0; i < menuArraySize; i++) {
    if (menus[i].parentid == parentid) {  // Перебираем все элементы с одним родителем
      if (firstID == -1) firstID = i;     // Запоминаем первый элемент списка

      if (menus[i].id == id) {
        actualID = i;                     // Запоминаем актальный элемент списка
      }
      else {
        if (actualID == -1) {             // Если встретился элемент до актуального, делаем его предыдущим
          prevID = i;
        }
        else if (actualID != -1 && nextID == -1) { // Если встретился элемент после актуального, делаем его следующим
          nextID = i;
        }
      }
      lastID = i;                         // Каждый последующий элемент - последний
    }
  }

  if (nextID == -1) nextID = firstID;     // Если следующего элемента нет - по кругу выдаем первый
  if (prevID == -1) prevID = lastID;      // Если предыдущего элемента нет - по кругу выдаем последний

  //Serial.println("previusindex:" + (String)prevID + "  nextindex:" + (String)nextID);

  if (side == -1) return prevID ;         // В зависимости от направления вращения, выдаем нужный индекс
  else return nextID;
  return -1;
}



void A()
{
  int pinAValue = digitalRead(pinA);        // Получаем состояние пинов A и B
  int pinBValue = digitalRead(pinB);

  cli();                                    // Запрещаем обработку прерываний, чтобы не отвлекаться
  if (!pinAValue &&  pinBValue) state = 1;  // Если при спаде линии А на линии B лог. единица, то вращение в одну сторону
  if (!pinAValue && !pinBValue) state = -1; // Если при спаде линии А на линии B лог. ноль, то вращение в другую сторону
  if (pinAValue && state != 0) {
    if (state == 1 && !pinBValue || state == -1 && pinBValue) { // Если на линии А снова единица, фиксируем шаг
      if (state == 1)   flagCW = true;      // Флаг вращения по часовой стрелке
      if (state == -1) flagCCW = true;      // Флаг вращения против часовой стрелки
      state = 0;
    }
  }
  sei();                                    // Разрешаем обработку прерываний
}

void Button()
{
  if (millis() - timeButtonDown < 50) return;
  int pinButValue = digitalRead(pinButton);   // Получаем состояние пина кнопки

  cli();                                      // Запрещаем обработку прерываний, чтобы не отвлекаться
  timeButtonDown = millis();                  // Запоминаем время нажатия/отжатия

  if (!pinButValue) {                         // При нажатии подается инвертированный сигнал
    isButtonDown = true;                      // Устанавливаем флаг нажатия кнопки
  }
  else if (isButtonDown) {                    // Если кнопка отжата, смотрим не было ли выполнено действие
    if (!longPressReleased) {                 // Если долгое нажатие не было ни разу отработано, то...
      flagButton = true;                      // Если не было удержания, ставим флаг события обычного нажатия
    }
    isButtonDown = false;                     // Сбрасываем флаг нажатия
    longPressReleased = false;                // Сбрасываем флаг длительного удержания
  }
  sei();                                      // Разрешаем обработку прерываний
}





//   ██████╗             ██████╗     ███████╗    ███████╗            ███╗   ███╗    ███████╗    ███╗   ██╗    ██╗   ██╗
//  ██╔═████╗            ██╔══██╗    ██╔════╝    ╚══███╔╝            ████╗ ████║    ██╔════╝    ████╗  ██║    ██║   ██║
//  ██║██╔██║            ██████╔╝    █████╗        ███╔╝             ██╔████╔██║    █████╗      ██╔██╗ ██║    ██║   ██║
//  ████╔╝██║            ██╔══██╗    ██╔══╝       ███╔╝              ██║╚██╔╝██║    ██╔══╝      ██║╚██╗██║    ██║   ██║
//  ╚██████╔╝            ██████╔╝    ███████╗    ███████╗            ██║ ╚═╝ ██║    ███████╗    ██║ ╚████║    ╚██████╔╝
//   ╚═════╝             ╚═════╝     ╚══════╝    ╚══════╝            ╚═╝     ╚═╝    ╚══════╝    ╚═╝  ╚═══╝     ╚═════╝ 

#else  /////////////>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

int pinA      = 2; //Пин прерывания сигнальной линии
int pinButton = 3; //Пин прерывания нажатия кнопки
int pinB      = 4; //Любой другой пин

long timeButtonPressed = 1500;  // Долгое удержание кнопки после 1,5 секунд

volatile int state = 0;         // Переменная хранящая статус вращения

// Переменные хранящие состояние действия до его выполнения
volatile bool flagCW            = false;     // Было ли вращение по часовой стрелке
volatile bool flagCCW           = false;     // Было ли вращение против часовой стрелки
volatile bool flagButton        = false;     // Было ли нажатие кнопки
volatile bool flagButtonLong    = false;     // Было ли долгое удержание кнопки

volatile long timeButtonDown    = 0;         // Переменная хранящая время нажатия кнопки
volatile bool isButtonDown      = false;     // Переменная хранящая время нажатия кнопки
volatile bool longPressReleased = false;     // Переменная для фиксации срабатывания долгого нажатия

void setup()
{
  pinMode(pinA, INPUT);           // Пины в режим приема INPUT
  pinMode(pinB, INPUT);           // Пины в режим приема INPUT
  pinMode(pinButton, INPUT);      // Пины в режим приема INPUT

  attachInterrupt(0, A, CHANGE);        // Настраиваем обработчик прерываний по изменению сигнала на линии A
  attachInterrupt(1, Button, CHANGE);   // Настраиваем обработчик прерываний по изменению сигнала нажатия кнопки

  Serial.begin(9600);             // Включаем Serial
}


void loop()
{
  if (millis() - timeButtonDown > timeButtonPressed && isButtonDown) { // Время длительного удержания наступило
    flagButtonLong = true;
  }

  if (flagCW) {                           // Шаг вращения по часовой стрелке
    // ...
    Serial.println("turn_right");
    flagCW = false;                       // Действие обработано - сбрасываем флаг
  }
  if (flagCCW) {                          // Шаг вращения против часовой стрелки
    // ...
    Serial.println("turn_left");
    flagCCW = false;                      // Действие обработано - сбрасываем флаг
  }
  if (flagButton) {                       // Кнопка нажата
    // ...
    Serial.println("short_press");
    flagButton = false;                   // Действие обработано - сбрасываем флаг
  }
  if (flagButtonLong && isButtonDown) {   // Кнопка удерживается
    if (!digitalRead(pinButton) && millis() - timeButtonDown > timeButtonPressed) { // Защита от ложного срабатывания
      // ...
      Serial.println("long_press");
    }
    
    //=========================================== Настраиваем реакцию на долгое удержание кнопки ===============================================
    // Чтобы событие long_press во время удержания срботало только один раз, необходимо раскомментировать блок и закомментировать следующий
    //isButtonDown = false;                 // Программно "отжимаем" кнопку

    // Эти две строки отвечают за то, чтобы при долгом удержании кнопки, событие long_press повторялось каждые 1,5 секунды
    // Для того, чтобы изменить это поведение нужно закомментировать две эти строки и раскомментировать строку из предыдущего блока
    timeButtonDown = millis();            // Сбрасываем таймер
    longPressReleased = true;             // Флаг срабатывания долгого удержания, чтобы отсечь генерацию обычного нажатия при отпускании кнопки
    //==========================================================================================================================================

    flagButtonLong = false;               // Действие обработано - сбрасываем флаг
  }
}

void A()
{
  int pinAValue = digitalRead(pinA);        // Получаем состояние пинов A и B
  int pinBValue = digitalRead(pinB);

  cli();                                    // Запрещаем обработку прерываний, чтобы не отвлекаться
  if (!pinAValue &&  pinBValue) state = 1;  // Если при спаде линии А на линии B лог. единица, то вращение в одну сторону
  if (!pinAValue && !pinBValue) state = -1; // Если при спаде линии А на линии B лог. ноль, то вращение в другую сторону
  if (pinAValue && state != 0) {
    if (state == 1 && !pinBValue || state == -1 && pinBValue) { // Если на линии А снова единица, фиксируем шаг
      if (state == 1)   flagCW = true;      // Флаг вращения по часовой стрелке
      if (state == -1) flagCCW = true;      // Флаг вращения против часовой стрелки
      state = 0;
    }
  }
  sei();                                    // Разрешаем обработку прерываний
}

void Button()
{
  if (millis() - timeButtonDown < 50) return;
  int pinButValue = digitalRead(pinButton);   // Получаем состояние пина кнопки

  cli();                                      // Запрещаем обработку прерываний, чтобы не отвлекаться
  timeButtonDown = millis();                  // Запоминаем время нажатия/отжатия

  if (!pinButValue) {                         // При нажатии подается инвертированный сигнал
    isButtonDown = true;                      // Устанавливаем флаг нажатия кнопки
  }
  else if (isButtonDown) {                    // Если кнопка отжата, смотрим не было ли выполнено действие
    if (!longPressReleased) {                 // Если долгое нажатие не было ни разу отработано, то...
      flagButton = true;                      // Если не было удержания, ставим флаг события обычного нажатия
    }
    isButtonDown = false;                     // Сбрасываем флаг нажатия
    longPressReleased = false;                // Сбрасываем флаг длительного удержания
  }
  sei();                                      // Разрешаем обработку прерываний
}

#endif  ///////////////////>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>