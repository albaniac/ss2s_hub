// Объявляем переменные
byte actualIndex = 0;
bool isParamEditMode  = false;            // Флаг режима редактирования параметра
int tmpValue          = 0;                // Временная переменная для хранения изменяемого параметра


// ОПИСАНИЕ МАСИВА С МЕНЮ:

// 0 Идентификационный уникальный индекс ID
// 1 ID родителя
// 2 Является ли пункт изменяемым параметром
// 3 Актуальное значение
// 4 Минимально возможное значение параметра
// 5 Максимально возможное значение параметра

// ПОЗИЦИЯ ID --;

byte punktovMenuVsego = 85;

byte masMenu[][6] = {
    {1,0,0,0,0,0},     // МЕНЮ (ВОЙТИ)

    {2,1,0,0,0,0},             // Р4 СВЕТ (ВЫБОР РЕЖИМА)

    {3,2,0,0,0,0},                     // 2 РЕЖИМ ДОСВЕТКА (НАСТРОЙКА РЕЖИМА 2 1 0)

    {4,3,1,5,1,24},                            // 1 ВКЛЮЧЕНИЕ В ЧАСОВ            ON 1 h
    {5,3,1,30,0,59},                           // 1 ВКЛЮЧЕНИЕ В МИНУТ            ON 1 m
    {6,3,1,6,1,24},                            // 1 ВЫКЛЮЧЕНИЕ В ЧАСОВ          OFF 1 h 
    {7,3,1,30,0,59},                           // 1 ВЫКЛЮЧЕНИЕ В МИНУТ          OFF 1 m
    {8,3,1,20,1,24},                           // 2 ВКЛЮЧЕНИЕ В ЧАСОВ            ON 2 h
    {9,3,1,30,0,59},                           // 2 ВКЛЮЧЕНИЕ В МИНУТ            ON 2 m
    {10,3,1,22,1,24},                          // 2 ВЫКЛЮЧЕНИЕ В ЧАСОВ          OFF 2 h
    {11,3,1,30,0,59},                          // 2 ВЫКЛЮЧЕНИЕ В МИНУТ          OFF 2 m
    {12,3,0,0,0,0},                            // СОХРАНИТЬ                        SAVE

    {13,2,0,0,0,0},                    // 1 РЕЖИМ СВЕТОЦИКЛ (НАСТРОЙКА РЕЖИМА)

    {14,13,1,5,1,24},                          // ВКЛЮЧЕНИЕ В ЧАСОВ                ON h
    {15,13,1,30,0,59},                         // ВКЛЮЧЕНИЕ В МИНУТ                ON m
    {16,13,1,17,1,24},                         // ВЫКЛЮЧЕНИЕ В ЧАСОВ              OFF h
    {17,13,1,30,0,59},                         // ВЫКЛЮЧЕНИЕ В МИНУТ              OFF m
    {18,13,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {19,2,0,0,0,0},                    // 0 ОТКЛЮЧЕНО, РУЧНОЕ УПРАВЛЕНИЕ            OFF

    {20,1,0,0,0,0},            // Р3 ПОЛИВ (ВЫБОР РЕЖИМА 3 2 1 0)

    {21,20,0,0,0,0},                   // 3 ОТ ДАТЧИКА ПОЧВЫ (НАСТРОЙКА РЕЖИМА)

    {22,21,1,1,0,2},                           // ТИП ДАТЧИКА                     0 1 2
    {23,21,1,50,0,100},                        // ПОРОГ АНАЛОГОВОГО ДАТЧИКА  если тип 2
    {24,21,0,0,0,0},                           // СОХРАНИТЬ

    {25,20,0,0,0,0},                   // 2 ПО ВРЕМЕНИ (НАСТРОЙКА РЕЖИМА)

    {26,25,1,5,1,24},                          // 1 ВКЛЮЧЕНИЕ В ЧАСОВ            ON 1 h
    {27,25,1,15,0,59},                         // 1 ВКЛЮЧЕНИЕ В МИНУТ            ON 1 m
    {28,25,1,12,1,24},                         // 2 ВКЛЮЧЕНИЕ В ЧАСОВ            ON 2 h
    {29,25,1,15,0,59},                         // 2 ВКЛЮЧЕНИЕ В МИНУТ            ON 2 m
    {30,25,1,18,1,24},                         // 3 ВКЛЮЧЕНИЕ В ЧАСОВ            ON 3 h
    {31,25,1,15,0,59},                         // 3 ВКЛЮЧЕНИЕ В МИНУТ            ON 3 m
    {32,25,1,0,0,24},                          // ВРЕМЯ РАБОТЫ ЧАСОВ         POWER ON h
    {33,25,1,10,0,59},                         // ВРЕМЯ РАБОТЫ МИНУТ         POWER ON m
    {34,25,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {35,20,0,0,0,0},                   // 1 ЦИКЛИЧЕСКИЙ (НАСТРОЙКА РЕЖИМА)

    {36,35,1,4,0,24},                          // МЕЖДУ ПОЛИВАМИ ЧАСОВ          DELAY h
    {37,35,1,0,0,59},                          // МЕЖДУ ПОЛИВАМИ МИНУТ          DELAY m
    {38,35,1,0,0,24},                          // ВРЕМЯ РАБОТЫ ЧАСОВ         POWER ON h
    {39,35,1,10,0,59},                         // ВРЕМЯ РАБОТЫ МИНУТ         POWER ON m
    {40,35,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {41,20,0,0,0,0},                   // 0 ОТКЛЮЧЕНО, РУЧНОЕ УПРАВЛЕНИЕ            OFF

    {42,1,0,0,0,0},            // Р2 ТЕМПЕРАТУРА (ВЫБОР РЕЖИМА 3 2 1 0)

    {43,42,0,0,0,0},                   // 3 НАСТРАИВАЕМЫЙ (НАСТРОЙКА РЕЖИМА)

    {44,43,1,25,0,50},                         // ТЕМПЕРАТУРА ВКЛЮЧЕНИЯ              ON
    {45,43,1,23,0,50},                         // ТЕМПЕРАТУРА ВЫКЛЮЧЕНИЯ            OFF
    {46,43,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {47,42,0,0,0,0},                   // 2 НАГРЕВ (НАСТРОЙКА РЕЖИМА)

    {48,47,1,25,0,50},                         // ЖЕЛАЕМАЯ ТЕМПЕРАТУРА              VAL
    {49,47,1,2,0,10},                          // ГИСТЕРЕЗИС                        GIS
    {50,47,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {51,42,0,0,0,0},                   // 1 ОХЛАЖДЕНИЕ (НАСТРОЙКА РЕЖИМА)

    {52,51,1,20,0,50},                         // ЖЕЛАЕМАЯ ТЕМПЕРАТУРА              VAL
    {53,51,1,1,0,10},                          // ГИСТЕРЕЗИС                        GIS
    {54,51,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {55,42,0,0,0,0},                   // 0 ОТКЛЮЧЕНО, РУЧНОЕ УПРАВЛЕНИЕ            OFF


    {56,1,0,0,0,0},            // Р1 ВЛАЖНОСТЬ (ВЫБОР РЕЖИМА 3 2 1 0)

    {57,56,0,0,0,0},                   // 3 НАСТРАИВАЕМЫЙ (НАСТРОЙКА РЕЖИМА)

    {58,57,1,60,20,95},                        // ВЛАЖНОСТЬ ВКЛЮЧЕНИЯ                ON
    {59,57,1,80,20,95},                        // ВЛАЖНОСТЬ ВЫКЛЮЧЕНИЯ              OFF
    {60,57,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {61,56,0,0,0,0},                   // 2 УВЛАЖНЕНИЕ (НАСТРОЙКА РЕЖИМА)

    {62,61,1,80,20,95},                        // ЖЕЛАЕМАЯ ВЛАЖНОСТЬ                VAL
    {63,61,1,5,0,10},                          // ГИСТЕРЕЗИС                        GIS
    {64,61,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {65,56,0,0,0,0},                   // 1 СУШКА (НАСТРОЙКА РЕЖИМА)

    {66,65,1,60,20,95},                        // ЖЕЛАЕМАЯ ВЛАЖНОСТЬ                VAL
    {67,65,1,5,0,10},                          // ГИСТЕРЕЗИС                        GIS
    {68,65,0,0,0,0},                           // СОХРАНИТЬ                        SAVE

    {69,56,0,0,0,0},                   // 0 ОТКЛЮЧЕНО, РУЧНОЕ УПРАВЛЕНИЕ            OFF

    {70,1,0,0,0,0},            // РУЧНОЕ УПРАВЛЕНИЕ (ВХОД В УПРАВЛЕНИЕ)

    {71,70,0,0,0,0},                   // Р4 СВЕТ                                ON/OFF
    {72,70,0,0,0,0},                   // Р3 ПОЛИВ                               ON/OFF
    {73,70,0,0,0,0},                   // Р2 ТЕМПЕРАТУРА                         ON/OFF
    {74,70,0,0,0,0},                   // Р1 ВЛАЖНОСТЬ                           ON/OFF

    {75,1,1,200,0,255},        // ЯРКОСТЬ ДИСПЛЕЯ

    {76,1,0,0,0,0},            // НАСТРОЙКА ЧАСОВ

    {77,76,1,18,0,99},                  // ГОД
    {78,76,1,3,1,12},                   // МЕСЯЦ
    {79,76,1,22,1,31},                  // ДЕНЬ
    {80,76,1,4,1,7},                    // ДЕНЬ НЕДЕЛИ
    {81,76,1,12,1,23},                  // ЧАСЫ
    {82,76,1,30,0,59},                  // МИНУТЫ
    {83,76,1,0,0,59},                   // СЕКУНДЫ
    {84,76,0,0,0,0},                    // СОХРАНИТЬ                                SAVE

    {85,1,0,0,0,0}             // EXIT
};

void nameIDserial(byte _ID){

}

void nameIDlcd(byte _ID){

}






byte getMenuIndexByID(byte id) {        // Функция получения индекса пункта меню по его ID
    for (byte i = 0; i < punktovMenuVsego; i++) {
        if (masMenu[i][0] == id)  return i;
    }
    return 0;
}





byte getNearMenuIndexByID(byte parentid, byte id, byte side) { // Функция получения индекса пункта меню следующего или предыдущего от актуального
    byte prevID    = 0;   // Переменная для хранения индекса предыдущего элемента
    byte nextID    = 0;   // Переменная для хранения индекса следующего элемента
    byte actualID  = 0;   // Переменная для хранения индекса актуального элемента

    byte firstID   = 0;   // Переменная для хранения индекса первого элемента
    byte lastID    = 0;   // Переменная для хранения индекса последнего элемента

    for (byte i = 0; i < punktovMenuVsego; i++) {
        if (masMenu[i][1] == parentid) {  // Перебираем все элементы с одним родителем
            if (firstID == 0) firstID = i;     // Запоминаем первый элемент списка

            if (masMenu[i][0] == id) {
                actualID = i;                     // Запоминаем актальный элемент списка
            }
            else {
                if (actualID == 0) {             // Если встретился элемент до актуального, делаем его предыдущим
                    prevID = i;
                }
                else if (actualID != 0 && nextID == 0) { // Если встретился элемент после актуального, делаем его следующим
                    nextID = i;
                }
            }
            lastID = i;                         // Каждый последующий элемент - последний
        }
    }

    if (nextID == 0) nextID = firstID;     // Если следующего элемента нет - по кругу выдаем первый
    if (prevID == 0) prevID = lastID;      // Если предыдущего элемента нет - по кругу выдаем последний

    //Serial.println("previusindex:" + (String)prevID + "  nextindex:" + (String)nextID);

    if (side == 2) return prevID ;         // В зависимости от направления вращения, выдаем нужный индекс
    else return nextID;
    return 0;
}






void setActualMenu(byte v, byte h) {
    if (v != 0) {                                           // Двигаемся по вертикали
        if (v == 2) {                                        // Команда ВВЕРХ (отмена)
            if (isParamEditMode) {                              // Если параметр в режиме редактирования, то отменяем изменения
                isParamEditMode = false;
            }
            else{                                              // Если пункт меню не в режиме редактирования, перемещаемся к родителю

                if (masMenu[actualIndex][1] > 1) {            // Если есть куда перемещаться вверх (ParentID>0)
                    actualIndex = getMenuIndexByID(masMenu[actualIndex][1]);
                }
            }
        }
        else{                                                // Если команда ВНИЗ - входа/редактирования

            if (masMenu[actualIndex][2] && !isParamEditMode) { // Если не в режиме редактирования, то ...
                isParamEditMode = true;                           // Переходим в режим редактирования параметра
                tmpValue = masMenu[actualIndex][3];              // Временной переменной присваиваем актуальное значение параметра
            }
            else if (masMenu[actualIndex][2] && isParamEditMode) { // Если в режиме редактирования
                masMenu[actualIndex][3] = tmpValue;              // Сохраняем заданное значение
                isParamEditMode = false;                          // И выходим из режима редактирования
            }
            else {

                bool nochild = true;                              // Флаг, есть ли дочерние элементы
                for (byte i = 0; i < punktovMenuVsego; i++) {
                    if (masMenu[i][1] == masMenu[actualIndex][0]) {
                        actualIndex = i;                              // Если есть, делаем первый попавшийся актуальным элементом
                        nochild = false;                              // Потомки есть
                        break;                                        // Выходим из for
                    }
                }

                if (nochild) {                     // Если же потомков нет, воспринимаем как команду
                    Serial.println("Executing command... " + (String)masMenu[actualIndex][0] + " OK"); // И здесь обрабатываем по своему усмотрению
                }
            }
        }
    }

    if (h != 0) {                                           // Если горизонтальная навигация
        if (isParamEditMode) {                                // В режиме редактирования параметра
            tmpValue += h;                                      // Изменяем его значение и ...
            // ... контроллируем, чтобы оно осталось в заданном диапазоне
            if (tmpValue > masMenu[actualIndex][5]) {
                tmpValue = masMenu[actualIndex][5];
            }

            if (tmpValue < masMenu[actualIndex][4]) {
                tmpValue = masMenu[actualIndex][4];
            }
        }
        else {     // Если режим редактирования не активен, навигация среди потомков одного родителя
            actualIndex = getNearMenuIndexByID(masMenu[actualIndex][1], masMenu[actualIndex][0], h);
        }
    }

  // Отображаем информацию в Serial
    if (isParamEditMode) {
        Serial.println(" > " + (String)masMenu[actualIndex][0] /*name*/ + ": " +  
                        (String)tmpValue +
                        "  min:" + (String)masMenu[actualIndex][4] +
                        ", max:" + (String)masMenu[actualIndex][5]);
    }
    else {
        if (masMenu[actualIndex][2]) {
            Serial.println((String)masMenu[actualIndex][0] /*name*/ + ": " + (String)masMenu[actualIndex][3]);
        }
        else {
            Serial.println((String)masMenu[actualIndex][0] /*name*/ );
        }
    }
}






void extMenuSetup(){
    actualIndex = getMenuIndexByID(0);    // Main - актуальный элемент меню
    setActualMenu(0, 0);                  // Выводим в Serial актуальный элемент меню
}






void extMenuLoop(){
    byte vmenu = 0;  // Переменная хранящая действие по вертикали 1 - вход в меню, 2 - выход из меню
    byte hmenu = 0;             // Переменная хранящая действие по горизонтали 1 - вправо, 2 - влево

    if (millis() - timeButtonDown > timeButtonPressed && isButtonDown) { // Время длительного удержания наступило
        flagButtonLong = true;
    }

    if (flagCW) {               // Шаг вращения по часовой стрелке
        hmenu = 1;
        //Serial.println("right");
        flagCW = false;           // Действие обработано - сбрасываем флаг
    }

    if (flagCCW) {              // Шаг вращения против часовой стрелки
        hmenu = 2;
        //Serial.println("left");
        flagCCW = false;          // Действие обработано - сбрасываем флаг
    }

    if (flagButton) {           // Кнопка нажата
        vmenu = 1;                // По нажатию кнопки - переходим на уровень вниз
        //Serial.println("button");
        flagButton = false;       // Действие обработано - сбрасываем флаг
    }

    if (flagButtonLong && isButtonDown) {   // Кнопка удерживается
        if (!digitalRead(pinButton) && millis() - timeButtonDown > timeButtonPressed) { // Защита от ложного срабатывания
        // ...
         vmenu = 2;             // По удержанию кнопки - возвращаемся на уровень вверх
        //Serial.println("long_press");
        }
    
        //================================= Настраиваем реакцию на долгое удержание кнопки =========
        // Для того, чтобы изменить это поведение, измените настройки в блоке ENKODER V
        #if LONG_PRESS_CONTINUES == 0
        // при долгом удержании кнопки, событие long_press повторяется каждые 1,5 секунды
        timeButtonDown = millis(); // Сбрасываем таймер
        longPressReleased = true;  // Флаг удерж. чтоб отсечь обычное нажатие при отпускании кнопки
        #else
        // при долгом удержании кнопки, событие long_press повторялось 1 раз
        isButtonDown = false;                   // Программно "отжимаем" кнопку
        #endif
        //==========================================================================================

        flagButtonLong = false;               // Действие обработано - сбрасываем флаг
    }
    if (vmenu != 0 || hmenu != 0) setActualMenu(vmenu, hmenu); // Если было действие - реагируем на него
}
